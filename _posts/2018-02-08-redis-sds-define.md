---
layout: post
title:  "redis中的SDS"
date:   2018-02-08 22:22:48 +0800
categories: reris
---
### 什么是SDS
SDS(Simple Dynamic String)，redis中的非字面量字符串都存储在SDS中。
举个例子吧：
执行`reids> SET msg "hello world"`这么一句话，
redis在数据结构中创建一个新的键值对，其中：
键值对的键是一个字符串对象，对象的底层实现是一个保存着字符串"msg"的SDS。
键值对的值也是一个字符串对象，对象的底层实现是一个保存着字符串"hello world"的SDS。

每个sds.h/sdshds 保存着SDS的数据结构：
```cpp
struct sdshdr{
    //buf数组中已使用的字节的数量
    int len;
    //buf数组中未使用的字节的数量
    int free;
    //字节数组，保存字符串
    char buf[];
}
```
和C语言一样，SDS的buf数组的字符串后的第一个字符保存为空字符```'/0'```，并且不计算在字符串长度内，添加空字符的操作由SDS自动完成，所以SDS可以直接重用一部分C字符串库函数。
*for example* : ```printf("%s", s->buf)```

### SDS与C字符串的区别
主要区别见下表，后面会逐条详细介绍。
|C字符串|SDS|
|---|---|
|获取字符串长度的复杂度为O(N)| 获取字符串长度的复杂度为O(1)|
|API是不安全的，可能会造成缓冲区溢出|API是安全的，不会造成缓冲区溢出|
|修改字符串长度N此必然执行N次内存重分配|修改字符串长度N此最多需要执行N次内存重分配|
|只能保存文本数据|可以保存文本或者二进制数据|
|可以使用所有<string.h>库中的函数|可以使用部分<string.h>库中的函数|

##### 常数复杂度获取字符串长度
C语言获取字符串长度需要遍历字符串直至遇到```/0```，时间复杂度为O(N)，而SDS只需要访问len属性就可以了，时间复杂度为O(1)。
设置和更新SDS长度的工作是由SDS API在执行时自动完成的，使用SDS无须进行任何手动修改长度的工作。

##### 杜绝缓冲区溢出
C字符串非常容易造成缓冲区溢出，如strcat方法。
在SDS API对SDS进行修改是，会首先检查SDS的空间是否满足修改所需的要求，如果不满足的话，API会自动将SDS的空间扩展至执行修改所需要的大小，然后执行实际的修改操作。

##### 减少修改字符串时带来的内存重分配次数
我们知道C字符串的底层是一个N+1长度的字符数组，所以每次增长或缩短一个C语言字符串，程序总要对保存这个C字符串的数组进行一次内从重分配操作。
* 如果是扩展字符串，比如拼接操作，那么执行这个操作之前，程序需要先通过内存重分配来扩展底层数组的空间大小——如果没有这一步就会产生缓冲区溢出。
* 如果程序执行的是缩短字符串操作，如截断，那么执行这个操作之后，程序需要通过内存重分配来释放字符串不再使用的那部分空间——如果忘了这一步就会产生内存泄露。

内存重分配设计了复杂的算法，还可能需要执行系统调用，所以它通常是一个比较耗时的操作：
    >在一般程序中，如果修改了字符串长度的情况不太常出现，那么每次修改都执行一次内存重分配是可以接受的；
    
   >但是Redis作为数据库，对速度的要求比较严苛，数据被频繁修改，所以不允许有大量的重分配造成的性能影响。

SDS通过未使用的空间，实现了空间预分配和懒惰空间释放两种优化策略。
###### 1. 空间预分配
当扩展SDS字符串，SDS的空间不足时，SDS会同时分配一些额外的free空间，这样减少连续执行字符串增长所需的内存重分配次数。分配策略如下：
    1. 如果新的字符串长度小于1MB，那么会同时分配一个相等长度的free空间，也就是说如果新的字符串长度为n个字节，那么SDS会分配n + n + 1的长度的字节。
    2. 如果新字符串的长度大于1MB，那么就分配固定1MB大小的free空间，所以SDS的新buf为n + 1MB + 1个字节。

###### 2. 惰性空间释放
当SDS的API缩短SDS的字符串时，SDS并不立即释放所拥有的内存，而是通过修改free属性把不用的空间保存下来，以备后面的不时之需。当然，SDS也提供了API来真正的释放内存，所以不用担心本策略会造成内存浪费。

##### 二进制安全
C字符串中的字符必须符合某种编码（如ASCII），并且除了字符串末尾外，不允许出现空字符，否则最先被程序读入的空字符将被误认为是字符串的结尾，这些限制使得C字符串只能保存文本数据，而不能保存像图片、视频、音频、压缩文件这样的二进制数据。如果有一个使用空字符来分隔单词的特殊数据格式，那么就麻烦了，第一个单词之后的内容都识别不到了。
Redis作为数据库，需要拥有存储各种类型数据的能力，所以SDS API会以处理二进制数据的方式来处理buf数组中的数据，而不会对数据做任何的假设、过滤、限制等操作。所以我们将SDS的buf数组成为**字节数组**。

##### 兼容部分C字符串函数
因为SDS的数据末尾总是一个空字符，那么保证了能够在C字符串上进行的操作在SDS的数据上也可以完成，这样就可以重用<string.h>中的大量的C字符串函数。




